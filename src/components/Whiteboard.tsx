import React, { useEffect, useRef, useState, useCallback } from 'react';
import * as fabric from 'fabric';
import './Whiteboard.css';
import Toolbar from './Toolbar';
import UndoButton from './UndoButton';
import FloatingMenu from './FloatingMenu/FloatingMenu';
import ImageUploader from './ImageUpload/ImageUploader';
import { ProcessedImage } from './ImageUpload/ImageProcessor';
import { PhotoEffect } from './ImageUpload/PhotoEffect/PhotoEffect';
import { FloatingButton } from './ImageSticker/components/FloatingButton';
import { FloatingButtonPosition } from './ImageSticker/services/types';
import { LogViewer } from './LogViewer/LogViewer';
import { AIGenerationPanel } from './AIGeneration/AIGenerationPanel';

// Type alias for Fabric.js Canvas instance with custom properties if any
// (Currently, freeDrawingBrush is a standard property but explicitly typed for clarity)
interface FabricCanvas extends fabric.Canvas {
  freeDrawingBrush?: fabric.PencilBrush;
}

// Interface for storing a snapshot of the canvas state for history
interface DrawingState {
  canvasState: string; // JSON string representation of canvas objects
  timestamp: number;   // Timestamp of when the state was saved
}

// Props for the Whiteboard component
interface WhiteboardProps {
  width?: number;
  height?: number;
  isDrawingMode?: boolean;
}

// Whiteboard component: Main component for the drawing canvas
const Whiteboard = ({ 
  width = 800, 
  height = 600, 
  isDrawingMode: initialIsDrawingMode = true // Renamed prop to avoid conflict with canvas property
}: WhiteboardProps) => {
  // Refs for canvas DOM element and Fabric canvas instance
  const canvasElRef = useRef<HTMLCanvasElement>(null);
  const fabricCanvasRef = useRef<FabricCanvas | null>(null);

  // State for UI elements and drawing properties
  const [menuPosition, setMenuPosition] = useState<{ x: number; y: number } | null>(null);
  const [clickPosition, setClickPosition] = useState<{ x: number; y: number } | null>(null);
  const [brushSize, setBrushSize] = useState(5);
  const [brushColor, setBrushColor] = useState('#000000');
  const [history, setHistory] = useState<DrawingState[]>([]);
  
  // State for sticker button visibility and position
  const [stickerButtonPosition, setStickerButtonPosition] = useState<FloatingButtonPosition | null>(null);

  // State for AI generation panel - isAIGenerationOpen might not be needed if panel is fully replaced
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [isAIGenerationOpen, setIsAIGenerationOpen] = useState(false); 
  // canvasSnapshot is still useful for analysis/generation
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [canvasSnapshot, setCanvasSnapshot] = useState<string>(''); 

  // State for log viewer
  const [isLogViewerOpen, setIsLogViewerOpen] = useState(false);

  // --- Helper Functions ---
  
  // ÁßªÈô§Êú™‰ΩøÁî®ÁöÑcreateBrushÂáΩÊï∞ - Áé∞Âú®ÈÉΩÁî®ÂÜÖËÅîÂàõÂª∫
  // ÁßªÈô§Êú™‰ΩøÁî®ÁöÑrecordCanvasStateÂáΩÊï∞ - Áé∞Âú®ÈÉΩÁî®ÂÜÖËÅîËÆ∞ÂΩï  
  // ÁßªÈô§Êú™‰ΩøÁî®ÁöÑgenerateCanvasSnapshotÂáΩÊï∞ - Áé∞Âú®ÈÉΩÁî®ÂÜÖËÅîÁîüÊàê
  // ÁßªÈô§Êú™‰ΩøÁî®ÁöÑhandleUndoÂáΩÊï∞ - Áé∞Âú®ÈÉΩÁî®ÂÜÖËÅîÂ§ÑÁêÜ
  // ÁßªÈô§Êú™‰ΩøÁî®ÁöÑmanageSelectionRectÂáΩÊï∞ - Áé∞Âú®ÈÉΩÁî®ÂÜÖËÅîÁÆ°ÁêÜ

  // --- Callbacks ---

  // Â§ÑÁêÜÁîªÁ¨îÂ§ßÂ∞èÂèòÂåñ
  const handleBrushSizeChange = useCallback((newSize: number) => {
    setBrushSize(newSize);
    const canvas = fabricCanvasRef.current;
    if (canvas?.freeDrawingBrush) {
      canvas.freeDrawingBrush.width = newSize;
    }
  }, []);

  // Â§ÑÁêÜÁîªÁ¨îÈ¢úËâ≤ÂèòÂåñ - ‰∏∫Êú™Êù•ÂäüËÉΩÈ¢ÑÁïô
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const handleBrushColorChange = useCallback((newColor: string) => {
    setBrushColor(newColor);
    const canvas = fabricCanvasRef.current;
    if (canvas?.freeDrawingBrush) {
      canvas.freeDrawingBrush.color = newColor;
    }
  }, []);

  // Â§ÑÁêÜAIÁîüÊàêÈù¢ÊùøÊâìÂºÄ
  const handleOpenAIPanel = useCallback(() => {
    // ÂÜÖËÅîÂø´ÁÖßÁîüÊàê
    const canvas = fabricCanvasRef.current;
    if (!canvas) {
      console.error('[Whiteboard] Canvas not available for snapshot');
      return;
    }
    try {
      const dataURL = canvas.toDataURL({
        format: 'png',
        quality: 0.8,
        multiplier: 1,
      });
      
      // Auto-download PNG
      const link = document.createElement('a');
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      link.href = dataURL;
      link.download = `whiteboard-snapshot-${timestamp}.png`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      setCanvasSnapshot(dataURL);
      setIsAIGenerationOpen(true);
    } catch (error) {
      console.error('[Whiteboard] Failed to generate snapshot:', error);
      alert('Êó†Ê≥ïËé∑ÂèñÁîªÊùøÂø´ÁÖßÔºåËØ∑ÈáçËØï');
    }
  }, []);

  // Â§ÑÁêÜAIÁîüÊàêÁöÑÂõæÁâá
  const handleAIImageGenerated = useCallback((imageUrl: string) => {
    const canvas = fabricCanvasRef.current;
    if (!canvas) {
      console.error('[Whiteboard] Canvas‰∏çÂèØÁî®ÔºåÊó†Ê≥ïÊ∑ªÂä†ÂõæÁâá');
      return;
    }

    // ‰øùÂ≠òÂΩìÂâçÁîªÂ∏ÉÁä∂ÊÄÅ
    const currentDrawingMode = canvas.isDrawingMode;
    const currentBrush = canvas.freeDrawingBrush;

    const img = new Image();
    img.crossOrigin = 'anonymous';
    
    img.onload = () => {
      try {
        const canvasCenter = {
          x: canvas.getWidth() / 2,
          y: canvas.getHeight() / 2
        };
        const imagePosition = {
          x: clickPosition?.x || canvasCenter.x - img.width / 4,
          y: clickPosition?.y || canvasCenter.y - img.height / 4
        };

        const fabricImage = new fabric.Image(img, {
          left: imagePosition.x,
          top: imagePosition.y,
          scaleX: 0.5,
          scaleY: 0.5,
          selectable: true,
          hasControls: true,
          evented: true
        });

        canvas.add(fabricImage);
        canvas.setActiveObject(fabricImage);
        
        // ÊÅ¢Â§çÁîªÂ∏ÉÁªòÂõæÁä∂ÊÄÅ
        canvas.isDrawingMode = currentDrawingMode;
        if (!currentBrush) {
          const brush = new fabric.PencilBrush(canvas);
          brush.width = canvas.freeDrawingBrush?.width || brushSize;
          brush.color = canvas.freeDrawingBrush?.color || brushColor;
          (brush as any).decimate = 8;
          (brush as any).controlPointsNum = 2;
          canvas.freeDrawingBrush = brush;
        } else {
          canvas.freeDrawingBrush = currentBrush;
        }
        canvas.renderAll();

        requestAnimationFrame(() => {
          // ËÆ∞ÂΩïÂéÜÂè≤Áä∂ÊÄÅ - ÂÜÖËÅîÈÅøÂÖç‰æùËµñ
          const currentCanvas = fabricCanvasRef.current;
          if (currentCanvas) {
            const currentState: DrawingState = {
              canvasState: JSON.stringify(currentCanvas.toJSON()),
              timestamp: Date.now()
            };
            setHistory(prev => {
              const newHistory = [...prev, currentState].slice(-20); 
              return newHistory;
            });
          }
        });
      } catch (error) {
        console.error('[Whiteboard] ÂõæÁâáÊ∑ªÂä†Âà∞ÁîªÂ∏ÉÂ§±Ë¥•:', error);
        // ÊÅ¢Â§çÁîªÂ∏ÉÁä∂ÊÄÅ
        canvas.isDrawingMode = currentDrawingMode;
        if (!currentBrush) {
          const brush = new fabric.PencilBrush(canvas);
          brush.width = canvas.freeDrawingBrush?.width || brushSize;
          brush.color = canvas.freeDrawingBrush?.color || brushColor;
          (brush as any).decimate = 8;
          (brush as any).controlPointsNum = 2;
          canvas.freeDrawingBrush = brush;
        } else {
          canvas.freeDrawingBrush = currentBrush;
        }
        canvas.renderAll();
      }
    };

    img.onerror = (errorEvent) => {
      console.error('[Whiteboard] ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•:', errorEvent);
      // ÊÅ¢Â§çÁîªÂ∏ÉÁä∂ÊÄÅ
      canvas.isDrawingMode = currentDrawingMode;
      if (!currentBrush) {
        const brush = new fabric.PencilBrush(canvas);
        brush.width = canvas.freeDrawingBrush?.width || brushSize;
        brush.color = canvas.freeDrawingBrush?.color || brushColor;
        (brush as any).decimate = 8;
        (brush as any).controlPointsNum = 2;
        canvas.freeDrawingBrush = brush;
      } else {
        canvas.freeDrawingBrush = currentBrush;
      }
    };

    img.src = imageUrl;
  }, [clickPosition, brushSize, brushColor]);

  // --- Effects --- 

  // Effect for initializing and managing the Fabric canvas instance
  useEffect(() => {
    console.log('üé® [Whiteboard] Canvas initialization effect triggered');
    
    if (!canvasElRef.current) {
      console.warn('‚ùå [Whiteboard] Canvas element not available');
      return;
    }

    // Èò≤Ê≠¢ÈáçÂ§çÂàùÂßãÂåñ - Âè™Âú®È¶ñÊ¨°ÊåÇËΩΩÊó∂ÂàõÂª∫
    if (fabricCanvasRef.current) {
      console.log('‚úÖ [Whiteboard] Canvas already exists, skipping initialization');
      return;
    }

    console.log('üöÄ [Whiteboard] Creating new canvas instance');
    const canvasInstance = new fabric.Canvas(canvasElRef.current, {
      width,
      height,
      backgroundColor: '#ffffff',
      isDrawingMode: initialIsDrawingMode,
    }) as FabricCanvas;

    // ÂàùÂßãÁîªÁ¨îËÆæÁΩÆ - ‰ΩøÁî®ÂàùÂßãÂõ∫ÂÆöÂÄºÔºåÂêéÁª≠ÈÄöËøáÂè¶‰∏Ä‰∏™effectÊõ¥Êñ∞
    console.log('üñåÔ∏è [Whiteboard] Setting up initial brush');
    const brush = new fabric.PencilBrush(canvasInstance);
    brush.width = 5; // ÂàùÂßãÂõ∫ÂÆöÂÄº
    brush.color = '#000000'; // ÂàùÂßãÂõ∫ÂÆöÂÄº
    (brush as any).decimate = 8;
    (brush as any).controlPointsNum = 2;
    canvasInstance.freeDrawingBrush = brush;
    
    // ËÆæÁΩÆcanvasÂ±ûÊÄß
    canvasInstance.renderOnAddRemove = true;
    canvasInstance.preserveObjectStacking = true;

    // ÁªòÂà∂ÂºÄÂßã‰∫ã‰ª∂ - ËêΩÁ¨îLOG
    const handleDrawingStart = (e: any) => {
      console.log('‚úèÔ∏è [Whiteboard] Drawing STARTED at:', e.pointer);
      console.log('üìä [Whiteboard] Current canvas objects count:', canvasInstance.getObjects().length);
    };

    // Ë∑ØÂæÑÂàõÂª∫‰∫ã‰ª∂ - ÂÖ≥ÈîÆÁöÑÁªòÂà∂ÂÆåÊàêLOG
    const handlePathCreated = (e: fabric.TEvent & { path: fabric.Path }) => {
      console.log('üéØ [Whiteboard] ===== PATH CREATED =====');
      console.log('üìê [Whiteboard] Path object:', e.path);
      console.log('üìä [Whiteboard] Canvas objects BEFORE adding path:', canvasInstance.getObjects().length);
      
      // Á´ãÂç≥Ê£ÄÊü•ÂØπË±°ÊòØÂê¶Ë¢´Ê∑ªÂä†
      setTimeout(() => {
        const objectCount = canvasInstance.getObjects().length;
        console.log('üìä [Whiteboard] Canvas objects AFTER path creation:', objectCount);
        
        if (objectCount === 0) {
          console.error('üö® [Whiteboard] CRITICAL BUG: All objects disappeared after path creation!');
        } else {
          console.log('‚úÖ [Whiteboard] Path successfully preserved, total objects:', objectCount);
        }
      }, 10);

      // Âª∂ËøüÊ£ÄÊü•ÊòØÂê¶ÊúâÊ∏ÖÁ©∫‰∫ã‰ª∂
      setTimeout(() => {
        const finalCount = canvasInstance.getObjects().length;
        console.log('üîç [Whiteboard] Final object count after 1 second:', finalCount);
        if (finalCount === 0) {
          console.error('üö® [Whiteboard] Objects disappeared after 1 second - possible state refresh bug!');
        }
      }, 1000);
    };

    // ÂØπË±°Ê∑ªÂä†‰∫ã‰ª∂
    const handleObjectAdded = (e: fabric.TEvent & { target: fabric.Object }) => {
      console.log('‚ûï [Whiteboard] Object ADDED:', e.target.type, 'Total objects:', canvasInstance.getObjects().length);
    };

    // ÂØπË±°ÁßªÈô§‰∫ã‰ª∂ - ÂÖ≥ÈîÆÁöÑÊ∂àÂ§±ÁõëÊéß
    const handleObjectRemoved = (e: fabric.TEvent & { target: fabric.Object }) => {
      console.error('‚ûñ [Whiteboard] Object REMOVED:', e.target.type, 'Remaining objects:', canvasInstance.getObjects().length);
      console.trace('üìç [Whiteboard] Object removal stack trace');
    };

    // ÁîªÂ∏ÉÊ∏ÖÁ©∫‰∫ã‰ª∂ - ËøôÊòØÂØºËá¥ÁªòÂà∂Ê∂àÂ§±ÁöÑ‰∏ªË¶ÅÂéüÂõ†
    const handleCanvasCleared = () => {
      console.error('üßπ [Whiteboard] CANVAS CLEARED! This causes drawing disappearance!');
      console.trace('üìç [Whiteboard] Canvas clear stack trace');
    };

    // Èº†Ê†áÊåâ‰∏ã‰∫ã‰ª∂
    const handleMouseDown = (e: any) => {
      console.log('üñ±Ô∏è [Whiteboard] Mouse DOWN at:', e.pointer);
      if (canvasInstance.isDrawingMode) {
        setStickerButtonPosition(null);
      }
    };

    // Èº†Ê†áÈáäÊîæ‰∫ã‰ª∂
    const handleMouseUp = (e: any) => {
      console.log('üñ±Ô∏è [Whiteboard] Mouse UP at:', e.pointer);
    };

    // ÁªëÂÆöÊâÄÊúâ‰∫ã‰ª∂ÁõëÂê¨Âô®
    console.log('üîó [Whiteboard] Binding event listeners');
    canvasInstance.on('mouse:down', handleMouseDown);
    canvasInstance.on('mouse:up', handleMouseUp);
    canvasInstance.on('path:created', handlePathCreated);
    canvasInstance.on('object:added', handleObjectAdded);
    canvasInstance.on('object:removed', handleObjectRemoved);
    canvasInstance.on('canvas:cleared', handleCanvasCleared);
    
    // ÁªòÂà∂Áõ∏ÂÖ≥‰∫ã‰ª∂ - ‰øÆÂ§ç‰∫ã‰ª∂ÁªëÂÆö
    canvasInstance.on('before:path:created', handleDrawingStart);

    // ÈîÆÁõò‰∫ã‰ª∂Â§ÑÁêÜ
    const handleKeyboard = (e: KeyboardEvent) => {
      if (e.ctrlKey && e.key === 'z') {
        e.preventDefault();
        console.log('‚Ü©Ô∏è [Whiteboard] Undo triggered');
        // Êí§ÈîÄÈÄªËæë‰øùÊåÅ‰∏çÂèò...
      }
    };

    window.addEventListener('keydown', handleKeyboard);
    fabricCanvasRef.current = canvasInstance;
    
    console.log('‚úÖ [Whiteboard] Canvas initialization completed successfully');

    // Ê∏ÖÁêÜÂáΩÊï∞
    return () => {
      console.log('üßπ [Whiteboard] Cleaning up canvas');
      window.removeEventListener('keydown', handleKeyboard);
      
      if (canvasInstance && fabricCanvasRef.current === canvasInstance) {
        // ÁßªÈô§ÊâÄÊúâ‰∫ã‰ª∂ÁõëÂê¨Âô®
        canvasInstance.off('mouse:down', handleMouseDown);
        canvasInstance.off('mouse:up', handleMouseUp);
        canvasInstance.off('path:created', handlePathCreated);
        canvasInstance.off('object:added', handleObjectAdded);
        canvasInstance.off('object:removed', handleObjectRemoved);
        canvasInstance.off('canvas:cleared', handleCanvasCleared);
        canvasInstance.off('before:path:created', handleDrawingStart);
        
        canvasInstance.dispose();
        fabricCanvasRef.current = null;
      }
    };
  }, [width, height, initialIsDrawingMode]); // üîß ‰øÆÂ§çÔºöÂè™‰æùËµñcanvasÂ∞∫ÂØ∏ÂíåÁªòÂõæÊ®°ÂºèÔºå‰∏ç‰æùËµñÁîªÁ¨îÂ±ûÊÄß

  // üîß ‰øÆÂ§çÁîªÁ¨îÊõ¥Êñ∞Effect - Ê∑ªÂä†ËØ¶ÁªÜLOGÁõëÊéß
  useEffect(() => {
    console.log('üñåÔ∏è [Whiteboard] Brush update effect triggered - Size:', brushSize, 'Color:', brushColor);
    
    const canvas = fabricCanvasRef.current;
    if (!canvas) {
      console.warn('‚ö†Ô∏è [Whiteboard] Canvas not available for brush update');
      return;
    }

    // Êõ¥Êñ∞ÁîªÁ¨îÂ±ûÊÄßÔºå‰øùÊåÅÁé∞ÊúâÁîªÁ¨îÂÆû‰æã
    if (canvas.freeDrawingBrush) {
      console.log('üîÑ [Whiteboard] Updating existing brush properties');
      canvas.freeDrawingBrush.width = brushSize;
      canvas.freeDrawingBrush.color = brushColor;
    } else {
      console.log('üÜï [Whiteboard] Creating new brush instance');
      const brush = new fabric.PencilBrush(canvas);
      brush.width = brushSize;
      brush.color = brushColor;
      (brush as any).decimate = 8;
      (brush as any).controlPointsNum = 2;
      canvas.freeDrawingBrush = brush;
    }
    
    console.log('‚úÖ [Whiteboard] Brush update completed - Width:', canvas.freeDrawingBrush?.width, 'Color:', canvas.freeDrawingBrush?.color);
  }, [brushSize, brushColor]); // Âè™‰æùËµñÁîªÁ¨îÂ±ûÊÄßÔºå‰∏ç‰ºöÂØºËá¥canvasÈáçÂª∫

  // Handler for context menu (right-click)
  const handleContextMenu = useCallback((event: React.MouseEvent<HTMLDivElement>) => {
    event.preventDefault();
    event.stopPropagation();
    
    if (!fabricCanvasRef.current) {
      console.warn('[Whiteboard] Canvas not available for context menu');
      return;
    }
    
    const canvas = fabricCanvasRef.current;
    const rect = event.currentTarget.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    const pointer = canvas.getPointer(event.nativeEvent);
    
    const objects = canvas.getObjects();
    const clickedImage = objects.find(obj => 
      obj.type === 'image' && 
      obj.containsPoint(pointer)
    ) as fabric.Image | undefined;

    if (clickedImage) {
      const bounds = clickedImage.getBoundingRect();
      
      // ÂÜÖËÅîÈÄâÊã©Áü©ÂΩ¢ÁÆ°ÁêÜ - ÁßªÈô§Áé∞ÊúâÁöÑÈÄâÊã©Áü©ÂΩ¢
      const existingSelection = objects.find(obj => 
        obj.type === 'rect' && 
        (obj as any).data?.type === 'selection-rect'
      );
      if (existingSelection) {
        canvas.remove(existingSelection);
      }

      // ÂàõÂª∫Êñ∞ÁöÑÈÄâÊã©Áü©ÂΩ¢
      const selectionRect = new fabric.Rect({
        left: bounds.left - 2,
        top: bounds.top - 2,
        width: bounds.width + 4,
        height: bounds.height + 4,
        fill: 'transparent',
        stroke: '#2196F3',
        strokeWidth: 2,
        selectable: false,
        evented: false,
        data: { type: 'selection-rect' }
      });
      
      canvas.add(selectionRect);
      canvas.renderAll();

      setStickerButtonPosition({
        x: bounds.left + bounds.width / 2,
        y: bounds.top - 20,
        target: clickedImage
      });
    } else {
      // ÁßªÈô§Áé∞ÊúâÈÄâÊã©Áü©ÂΩ¢
      const existingSelection = objects.find(obj => 
        obj.type === 'rect' && 
        (obj as any).data?.type === 'selection-rect'
      );
      if (existingSelection) {
        canvas.remove(existingSelection);
        canvas.renderAll();
      }

      setMenuPosition({ x: event.clientX, y: event.clientY });
      setClickPosition({ x, y });
      setStickerButtonPosition(null);
    }
  }, []);

  // Â§ÑÁêÜË¥¥Á∫∏ËΩ¨Êç¢
  const handleStickerConvert = useCallback((imageUrl: string) => {
    if (!imageUrl) {
      console.error('[Whiteboard] No image URL provided for sticker conversion');
      return;
    }

    const canvas = fabricCanvasRef.current;
    if (!canvas) {
      console.error('[Whiteboard] Canvas not available for sticker conversion');
      return;
    }

    // Record state before conversion
    const currentState: DrawingState = {
      canvasState: JSON.stringify(canvas.toJSON()),
      timestamp: Date.now()
    };
    setHistory(prev => {
      const newHistory = [...prev, currentState].slice(-20); 
      return newHistory;
    });

    // Close sticker button
    setStickerButtonPosition(null);
  }, []);

  // Â§ÑÁêÜÂõæÁâá‰∏ä‰º†
  const handleImageProcessed = useCallback(async (processedImage: ProcessedImage) => {
    if (!fabricCanvasRef.current || !clickPosition) {
        console.error('[Whiteboard] Canvas or click position not available for image upload');
        return;
    }

    const canvas = fabricCanvasRef.current;
    
    // ‰øùÂ≠òÂΩìÂâçÁîªÂ∏ÉÁä∂ÊÄÅ
    const currentDrawingMode = canvas.isDrawingMode;
    const currentBrush = canvas.freeDrawingBrush;
    
    const img = new Image();
    
    img.onload = () => {
      // ËÆ°ÁÆóÂõæÁâáÁº©ÊîæÊØî‰æãÔºåÁ°Æ‰øùÂõæÁâá‰∏ç‰ºöÂ§™Â§ß
      const maxSize = 250;
      const scale = Math.min(maxSize / img.width, maxSize / img.height, 1);
      
      const imagePosition = {
        x: clickPosition.x - (img.width * scale) / 2,
        y: clickPosition.y - (img.height * scale) / 2
      };
      
      const fabricImage = new fabric.Image(img, {
        left: imagePosition.x,
        top: imagePosition.y,
        scaleX: scale,
        scaleY: scale,
        selectable: false,
        hasControls: false,
        evented: false
      });

      try {
        // ÂÖàÊ∑ªÂä†ÂõæÁâáÂà∞ÁîªÂ∏ÉÔºåÁ°Æ‰øùÂõæÁâáËÉΩÊòæÁ§∫
        canvas.add(fabricImage);
        
        // ËÆæÁΩÆcanvasÂºïÁî®
        fabricImage.canvas = canvas;
        
        // Â∫îÁî®ÁÖßÁâáÊïàÊûúÔºåPhotoEffectÂÜÖÈÉ®Â∑≤ÁªèÂåÖÂê´Âä®Áîª
        PhotoEffect.applyPhotoEffect(fabricImage, {
          animation: {
            initial: { scale: 0.7, opacity: 0, rotation: -15 },
            final: { scale: 1, opacity: 1, rotation: PhotoEffect.getRandomRotation() },
            duration: 1400,
            easing: 'easeOutBack'
          }
        });

        // Á´ãÂç≥Ê∏≤ÊüìÔºå‰∏çÁ≠âÂæÖÂä®Áîª
        canvas.renderAll();

        // Á≠âÂæÖÂä®ÁîªÂÆåÊàêÂêéËÆæÁΩÆ‰∫§‰∫íÊÄß
        setTimeout(() => {
          fabricImage.set({ 
            selectable: true, 
            hasControls: true, 
            evented: true 
          });
          
          // Ê∑ªÂä†ÈÄâ‰∏≠‰∫ã‰ª∂ÁõëÂê¨
          fabricImage.on('selected', () => {
            const bounds = fabricImage.getBoundingRect();
            setStickerButtonPosition({
              x: bounds.left + bounds.width / 2,
              y: bounds.top - 20,
              target: fabricImage
            });
          });

          fabricImage.on('deselected', () => {
            setStickerButtonPosition(null);
          });
          
          // ÊÅ¢Â§çÁîªÂ∏ÉÁªòÂõæÁä∂ÊÄÅ
          canvas.isDrawingMode = currentDrawingMode;
          if (!currentBrush) {
            const brush = new fabric.PencilBrush(canvas);
            brush.width = canvas.freeDrawingBrush?.width || brushSize;
            brush.color = canvas.freeDrawingBrush?.color || brushColor;
            (brush as any).decimate = 8;
            (brush as any).controlPointsNum = 2;
            canvas.freeDrawingBrush = brush;
          } else {
            canvas.freeDrawingBrush = currentBrush;
          }
          canvas.renderAll();
          
          // ËÆ∞ÂΩïÂéÜÂè≤Áä∂ÊÄÅ - ÂÜÖËÅîÈÅøÂÖç‰æùËµñ
          const currentCanvas = fabricCanvasRef.current;
          if (currentCanvas) {
            const currentState: DrawingState = {
              canvasState: JSON.stringify(currentCanvas.toJSON()),
              timestamp: Date.now()
            };
            setHistory(prev => {
              const newHistory = [...prev, currentState].slice(-20); 
              return newHistory;
            });
          }
        }, 100); // Áº©Áü≠Á≠âÂæÖÊó∂Èó¥ÔºåËÆ©Áî®Êà∑Êõ¥Âø´ÁúãÂà∞ÊïàÊûú

      } catch (error: any) {
        console.error('[Whiteboard] ÁÖßÁâáÊïàÊûúÂ∫îÁî®Â§±Ë¥•:', error);
        // fallback: ÁÆÄÂçïÊ∑ªÂä†ÂõæÁâá
        canvas.add(fabricImage);
        fabricImage.set({ selectable: true, hasControls: true, evented: true });
        
        // ÊÅ¢Â§çÁîªÁ¨îÁä∂ÊÄÅ
        canvas.isDrawingMode = currentDrawingMode;
        if (!currentBrush) {
          const brush = new fabric.PencilBrush(canvas);
          brush.width = brushSize;
          brush.color = brushColor;
          (brush as any).decimate = 8;
          (brush as any).controlPointsNum = 2;
          canvas.freeDrawingBrush = brush;
        } else {
          canvas.freeDrawingBrush = currentBrush;
        }
        canvas.renderAll();
        
        // ËÆ∞ÂΩïÂéÜÂè≤Áä∂ÊÄÅ - ÂÜÖËÅîÈÅøÂÖç‰æùËµñ
        const currentCanvas = fabricCanvasRef.current;
        if (currentCanvas) {
          const currentState: DrawingState = {
            canvasState: JSON.stringify(currentCanvas.toJSON()),
            timestamp: Date.now()
          };
          setHistory(prev => {
            const newHistory = [...prev, currentState].slice(-20); 
            return newHistory;
          });
        }
      }

      setMenuPosition(null);
      setClickPosition(null);
    };

    img.onerror = (errorEvent) => {
      console.error('[Whiteboard] ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•:', errorEvent);
      // ÊÅ¢Â§çÁîªÂ∏ÉÁä∂ÊÄÅ
      canvas.isDrawingMode = currentDrawingMode;
      if (!currentBrush) {
        const brush = new fabric.PencilBrush(canvas);
        brush.width = brushSize;
        brush.color = brushColor;
        (brush as any).decimate = 8;
        (brush as any).controlPointsNum = 2;
        canvas.freeDrawingBrush = brush;
      } else {
        canvas.freeDrawingBrush = currentBrush;
      }
      alert('ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
    };

    img.src = processedImage.dataUrl;
  }, [clickPosition, brushSize, brushColor]);

  return (
    <div className="whiteboard-wrapper">
      <Toolbar 
        brushSize={brushSize}
        onBrushSizeChange={handleBrushSizeChange}
      />
      
      <div className="ai-generation-trigger">
        <button
          className="ai-generation-btn"
          onClick={handleOpenAIPanel}
          title="AIÂàÜÊûêÁîªÊùøÂπ∂Ëá™Âä®ÁîüÊàêÂõæÁâá"
          disabled={isAIGenerationOpen}
        >
          {isAIGenerationOpen ? 'üé® ÁîüÊàê‰∏≠...' : 'üé® ÁîüÂõæ'}
        </button>
        <button 
          className="log-viewer-button"
          onClick={() => setIsLogViewerOpen(true)}
          title="Êü•ÁúãÁ≥ªÁªüÊó•Âøó"
        >
          üìä Êó•Âøó
        </button>
      </div>

      <div className="whiteboard-main-content">
        <div 
          className="whiteboard-container"
          onContextMenu={handleContextMenu}
        >
          <UndoButton 
            canUndo={history.length > 1}
            onUndo={() => {
              const currentCanvas = fabricCanvasRef.current;
              if (!currentCanvas) {
                console.warn('[Whiteboard] Cannot undo: canvas not available');
                return;
              }

              setHistory(prevHistory => {
                if (prevHistory.length <= 1) { 
                  return prevHistory; 
                }

                try {
                  const prevState = prevHistory[prevHistory.length - 2]; 
                  currentCanvas.loadFromJSON(JSON.parse(prevState.canvasState), () => {
                    currentCanvas.isDrawingMode = initialIsDrawingMode; 
                    // ÊÅ¢Â§çÁîªÁ¨îËÆæÁΩÆ - ‰ΩøÁî®ÂΩìÂâçÁä∂ÊÄÅÂÄºÔºåÁ°Æ‰øùÊí§ÈîÄÂêéÁîªÁ¨îÊ≠£Á°Æ
                    const currentBrushSize = fabricCanvasRef.current?.freeDrawingBrush?.width || 5;
                    const currentBrushColor = fabricCanvasRef.current?.freeDrawingBrush?.color || '#000000';
                    const brush = new fabric.PencilBrush(currentCanvas);
                    brush.width = currentBrushSize;
                    brush.color = currentBrushColor;
                    (brush as any).decimate = 8;
                    (brush as any).controlPointsNum = 2;
                    currentCanvas.freeDrawingBrush = brush;
                    currentCanvas.renderAll();
                  });
                  return prevHistory.slice(0, -1); 
                } catch (error) {
                  console.error('[Whiteboard] Undo failed:', error);
                  return prevHistory; 
                }
              });
            }}
          />
          <div className="canvas-wrapper">
            <canvas ref={canvasElRef} />
          </div>
          {menuPosition && (
            <ImageUploader onImageProcessed={handleImageProcessed}>
              {(triggerUpload) => (
                <FloatingMenu
                  position={menuPosition}
                  onUploadClick={triggerUpload}
                  onClose={() => {
                    setMenuPosition(null);
                    setClickPosition(null);
                  }}
                />
              )}
            </ImageUploader>
          )}
          {stickerButtonPosition && (
            <FloatingButton
              position={stickerButtonPosition}
              onConvert={handleStickerConvert}
              onClose={() => setStickerButtonPosition(null)}
              targetImage={stickerButtonPosition.target}
            />
          )}
        </div>
      </div>

      {/* AIÁîüÊàêÈù¢Êùø */}
      <AIGenerationPanel
        isOpen={isAIGenerationOpen} 
        onClose={() => setIsAIGenerationOpen(false)}
        canvasSnapshot={canvasSnapshot}
        onImageGenerated={handleAIImageGenerated}
      />

      {/* Êó•ÂøóÊü•ÁúãÂô® */}
      <LogViewer
        isOpen={isLogViewerOpen}
        onClose={() => setIsLogViewerOpen(false)}
      />
    </div>
  );
};

export default Whiteboard;
